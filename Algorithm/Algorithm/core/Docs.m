//
//  Docs.m
//  Algorithm
//
//  Created by 马鹏 on 2023/2/5.
//

#import "Docs.h"

@implementation Docs
/*  递归
+ (void)recursion(level, param1, param2,....) {
//    递归终止条件
    if level > max_level {
        return;
    }
//    处理数据
    process_data(level, data)
//    递归下去
    self.recursion(level+1, p1, p2....)
//    收尾工作
    reverse_state(level)
}
 
 
分治
 
 def divide_conquer(problem, param1, param2, ...):
 //   递归终点
    if problem is none:
        return
    //准备数据
    data = prepare_data(problem)
    subproblems = split_problem(problem,data)
 //解决子问题
 subResult1 = self.divide_conquer(subproblems[0], p1, ...)
 subResult2 = self.divide_conquer(subproblems[1], p1, ...)
 subResult3 = self.divide_conquer(subproblems[2], p1, ...)
 ...
 //处理子问题结果，从而得到最终结果
    result = process_result(subResult1,subResult2,subResult3,...)
*/



@end
